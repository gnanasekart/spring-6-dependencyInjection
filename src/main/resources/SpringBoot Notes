MyConfiguration file
This file contains Bean definitions and configuration settings for a Spring Boot application.


## Bean Annotations
- @Configuration: Indicates that the class can be used by the Spring IoC container as a source of bean definitions.
- @Bean: Indicates that a method produces a bean to be managed by the Spring container.
    - Bean name can be specified using the name attribute, else method name is used as the bean name.
- @ComponentScan: Configures component scanning directives for use with @Configuration classes.
- @Scope: Specifies the scope of a bean (singleton, prototype, request, session, etc.).
    - Default scope is singleton.
    - Singleton: A single instance/Object per Spring IoC container is created and used in other places.
    - Prototype: A new instance/Object each time the bean is requested.
    - Request: A single instance per HTTP request (web applications).
    - Session: A single instance per HTTP session (web applications).

Exception :-
1). org.springframework.beans.factory.NoUniqueBeanDefinitionException:
        No qualifying bean of type 'org.javaBasedConfiguration.Writer' available:
        expected single matching bean but found 2: pen,pencil

    - This exception occurs when there are multiple beans of the same type and Spring cannot determine which one to inject.
    - To resolve this, you can use @Qualifier annotation to specify which bean to inject. --> First Priority is Qualifier
    @Qualifier("beanName")
    - Alternatively, you can mark one of the beans as @Primary to indicate that it should be the default choice. --> Second Priority is Primary


Stereotype Annotations

@Component: Generic stereotype for any Spring-managed component.
@ComponentScan(basePackages = "com.example.package"): Specifies the packages to scan for annotated components.
@Autowired: Marks a constructor, field, setter method, or config method to be autowired by Spring's dependency injection facilities.
@Qualifier("beanName"): Specifies which bean to inject when multiple candidates are available.
@Primary: Indicates that a bean should be given preference when multiple candidates are qualified to autowire a single-valued dependency.


Spring Boot - Convention over Configuration

Dependency Injection
- Constructor Injection:
    @Autowired
    public Student(Pen pen) {
        System.out.println("Constructor Injection called");
        this.pen = pen;
    }

- Setter Injection:
    @Autowired
    public void setPen(Pen pen) {//Setter Injection
        System.out.println("Setter Injection called");
        this.pen = pen;
    }

- Field Injection:
    @Autowired
    private Pen pen;//Field Injection

Autowired


Loose Coupling
- @Primary: Marks a bean as the primary candidate for autowiring when multiple beans of the same type are present.
@Component
@Primary
public class Pen implements Writer
{
    @Override
    public void write() {
        System.out.println("Writing with Pen");
    }
}

- @Qualifier: Specifies which bean to inject when multiple candidates are available.
    @Autowired
    @Qualifier("pencil")
    private Writer writer;

To avoid tight coupling between classes, we use interfaces.
Once after implementing the interface method in one class. that particular class denoted with @Component annotation.
Now, in another class, we can use that interface as a reference data type and use @Autowired to inject the implementation class object.

-------------------------------------
Lombok Annotations

- @Getter: Generates getter methods for all fields.
- @Setter: Generates setter methods for all fields.
- @ToString: Generates a toString() method.
- @NoArgsConstructor: Generates a no-argument constructor.
- @AllArgsConstructor: Generates a constructor with 1 parameter for each field in the class.
- @Data: A shortcut for @Getter, @Setter, @ToString, @Equals
- @Builder: Implements the builder pattern for the class.
- @Slf4j: Generates a logger field in the class.
- @RequiredArgsConstructor: Generates a constructor with required arguments (final fields and fields marked with @NonNull).
- @NonNull: Marks a field as non-null, generating null checks in constructors and setters.
- @Value: Marks a field as final and generates a constructor for it.
- @SneakyThrows: Allows throwing checked exceptions without declaring them in the method signature.
- @Cleanup: Automatically closes resources after use.
- @Log: Generates a java.util.logging.Logger field in the class.
- @Synchronized: Generates synchronized methods for thread safety.
- @EqualsAndHashCode: Generates equals() and hashCode() methods.
- @FieldDefaults: Sets default access level and mutability for fields in the class.
- @chain: Generates chainable setter methods.

-------------------------------------

REST API

Client-Server Architecture

Server consist of
- Controller Layer: Handles HTTP requests and responses.
    @RestController: Combines @Controller and @ResponseBody, indicating that the class handles RESTful web services.

- Service Layer: Contains business logic.
    @Service: Indicates that the class holds business logic.

- Repository Layer: Manages data access and persistence.
    @Repository: Indicates that the class is a Data Access Object (DAO) that interacts with the database.


@GetMapping: Maps HTTP GET requests to handler methods.
@PostMapping: Maps HTTP POST requests to handler methods.
@PutMapping: Maps HTTP PUT requests to handler methods.
@DeleteMapping: Maps HTTP DELETE requests to handler methods.
@PathVariable: Binds a method parameter to a URI template variable.
@RequestParam: Binds a method parameter to a query parameter in the URL.
@RequestBody: Binds the HTTP request body to a method parameter.


----------------------------------------

JPA (Java Persistence API)
Hibernate - Object Relational Mapping (ORM) framework for managing relational data in Java applications.

JDBC (Java Database Connectivity)
7 steps to connect to the database using JDBC
1. Load the JDBC Driver
2. Establish a Connection
3. Create a Statement
4. Execute a Query
5. Process the ResultSet
6. Close the Resources
7. Handle Exceptions

To overcome the boilerplate code in JDBC, we use Data JPA with Hibernate.

Repository (Interface) extends JpaRepository<EntityClass, PrimaryKeyType>
- JpaRepository provides CRUD operations and pagination/sorting capabilities.


ORM (Object Relational Mapping)
- It is a technique that bridges the gap between the object-oriented Java code and the relational database.
- It allows developers to interact with the database using Java objects (called "entities") instead of writing raw SQL queries,
- which reduces boilerplate code and simplifies data persistence.

Other ORM tools in the market are:
1. Hibernate: The most popular and widely used ORM framework for Java applications. It is easy to integrate with Spring and Spring boot.
2. EclipseLink: An open-source ORM framework that is the reference implementation of JPA.
3. MyBatis: A persistence framework that offers SQL mapping and supports custom SQL queries.
4. SQLAlchemy: A popular ORM framework for Python applications.
5. Entity Framework: An ORM framework for .NET applications.

These all ORM tools by default follow the principle of JPA

### Key Components in Spring Boot ORM

Spring Boot simplifies the integration of ORM by providing auto-configuration and starter dependencies,
primarily using the Java Persistence API (JPA) specification and Hibernate as the default implementation.
1. JPA (Java Persistence API): This is a Java specification that defines a set of standard rules and interfaces for persistence. It is an API, not an implementation itself.
2. Hibernate: This is the most popular, full-featured, and default ORM framework that implements the JPA specifications in Spring Boot applications.
3. Spring Data JPA: This is a Spring framework module that adds an extra layer of abstraction on top of the JPA provider (Hibernate).
It significantly reduces the amount of code needed for data access by providing repository interfaces for common CRUD (Create, Read, Update, Delete) operations,
allowing developers to define queries through simple method names.

Example:-
Before using JPA, we use to write Student class with following fields
public class StudentCRUD {
    private int rollNo;
    private String name;
    private String technology;
}


Once after introducing JPA,
It is automatically create a Student table in the database with the fields.
Here the list of students details are stored as records in the Student table as Rows and Columns.
we need to annotate the Student class with @Entity and other relevant annotations to map it to a database table.


By Extends JPA Repository, we can perform CRUD operations without writing any boilerplate code.
Declare methods in the Repository interface with specific naming conventions to perform various queries.
For example, to find a student by name, we can define a method like findByName(String name) in the Repository interface.
Alternatively if we want to write custom queries, we can use native @Query annotation in the Repository interface methods.